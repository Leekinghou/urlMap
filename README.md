# 长短地址映射模块

## 1. 项目介绍
Web Project 在实际生产环境运行时会接收到很多短地址请求，这些短地址请求需要通过长地址进行重定向，这个过程需要通过数据库进行查询，这样会增加数据库的压力，同时也会增加请求的响应时间，因此需要对这些短地址进行缓存，这样可以减少数据库的压力，同时也可以减少请求的响应时间。

使用Go中内置的map实现以上需求：`map[string]string`

键的类型写在 [ ] 里面，后面跟的是值的类型

为解决Add类型请求改变url 存储时带来的线程安全问题，使用了标准库中的sync包的Mutex互斥锁

一个`RWMutex`有两个锁： 一个用于读取，一个用于写入。
多个客户端可以同时获得读取锁，但是只能有一个客户端能够获得写入锁（禁用所有读取器），从而有效的序列化更新，使他们连续的工作。

### 1.1 version 1.0项目功能
简单存储和读写

### 1.2 version 2.0项目功能
增加持久化存储

### 1.3 version 3.0项目功能
如果太多客户端试图同时添加URLs，那么会出现问题。
这是因为我们的map是一个全局变量，因此它是一个共享资源。如果多个客户端同时尝试添加URLs，那么它们可能会同时读取和写入map，这可能会导致数据丢失或者数据不一致。
为了解决这个问题，version2.0使用了互斥锁来保护map，以确保在同一时间只有一个客户端能够访问它。

但是由于锁定机制，每一条记录是立即写入磁盘的，这样会导致性能下降。磁盘写入可能会同时发生，并且根据你的操作系统的特性，可能会导致崩溃。
即使写入不会冲突，每个客户端在 Put 函数返回之前，必须等待他们的数据写入到磁盘。因此，在 I/O 负载大的系统上，客户端需要等待的时间将超过完成添加请求所必须的时间。

为了解决这个问题，version3.0使用了一个goroutine来处理写入请求，这样就可以在不影响性能的情况下，保证数据的一致性。
具体而言，是将 Put 与 Save 的过程解耦合：通过 Go 的并发机制做到这点。不再将记录直接保存到磁盘，而是发送它们到一个通道，这是一种缓冲，所以发送函数不需要再等待它。
然后，我们启动一个 goroutine 来处理这些记录，这样就可以在不影响性能的情况下，保证数据的一致性。
写入磁盘的保存过程从这个通道读取，并且是启动在一个叫 saveloop 的协程单独启动的线程上。主程序与 saveloop 是同时执行的，所以没有那么多的阻塞。

### 1.4 version 4.0项目功能
使用json存储

### 1.5 version 5.0项目功能
目前为止， `urlMap`作为单个进程运行，即使使用协程，在一台机器上运行的单个进程也只能提供这么多并发请求。

一个 `URL`缩短服务通常更多的是重定向（使用 `Get()` 读取），而不是添加（使用 `Put` 写入）。
因此，我们可以创建任意数量的只读从服务器用于缓存 `Get` 请求，并将 `Puts` 传递给主服务器，就像下面这个示例图：

![](https://image-20220620.oss-cn-guangzhou.aliyuncs.com/image/20230420170522.png)
多个从服务器进程要运行一个网络中另一台计算上的 `urlMap`应用的主实例，它们必须能够互相通信。
Go 的 `rpc` 包提供了一个通过网络连接进行函数调用的便利的方法，使` URLStore `成为一个` RPC 服务`，这些从服务器进程将处理 `Get` 请求去提供长 `urls` 。
当一个新的长` url `需要转换成一个短` url `（使用` Put() `方法）的时候，它们通过` rpc `连接将任务委托给主服务器进程；所以必须只有主服务器可以写入数据。

到目前为止， URLStore 的 Get() 与 Put() 方法都有签名：
```go
func (s *URLStore) Get(key string) string

func (s *URLStore) Put(url string) string
```
RPC 只能通过这种形式（t 是 T 类型的值）的方法工作：
```go
func (t T) Name(args *ArgType, reply *ReplyType) error
```
为了使 URLStore 成为一个 RPC 服务，我们需要去修改 Put 与 Get 方法，以便它们匹配这个函数的签名。这是结果：
```go
func (s *URLStore) Get(key, url *string) error

func (s *URLStore) Put(url, key *string) error
```

## 2. 项目结构
```
├── README.md
├── src 
│   ├── store.go // 定义了数据存储和处理它的函数
│   ├── main.go // 主函数
│   ├── key.go // 定义了key的生成函数
├── file 
    ├── store.gob // 存储数据的文件
    ├── store.json 
```
![](https://image-20220620.oss-cn-guangzhou.aliyuncs.com/image/20230419171551.png)

## 3. 改进  
- 美观： 用户界面可以更漂亮。你可以使用 Go 的 template 包实现

- 可靠性： 主 / 从 RPC 连接可以更可靠： 如果 客户端-服务器端 断开连接，客户端应该尝试重新拨号。一个 「拨号」 协程可以解决这个问题。

- 资源耗尽： 随着 URL 数据库的增长，内存使用可能成为一个问题。可以通过主服务器上 key 的分割（分片）来解决。

- 删除： 为了支持删除已经缩短的 URLs ， 主从服务器之间的交互将会变得更加复杂

- 日志： 添加日志记录，以便在出现问题时进行调试
