# 长短地址映射模块

## 1. 项目介绍
Web Project 在实际生产环境运行时会接收到很多短地址请求，这些短地址请求需要通过长地址进行重定向，这个过程需要通过数据库进行查询，这样会增加数据库的压力，同时也会增加请求的响应时间，因此需要对这些短地址进行缓存，这样可以减少数据库的压力，同时也可以减少请求的响应时间。

使用Go中内置的map实现以上需求：`map[string]string`

键的类型写在 [ ] 里面，后面跟的是值的类型

为解决Add类型请求改变url 存储时带来的线程安全问题，使用了标准库中的sync包的Mutex互斥锁

一个`RWMutex`有两个锁： 一个用于读取，一个用于写入。
多个客户端可以同时获得读取锁，但是只能有一个客户端能够获得写入锁（禁用所有读取器），从而有效的序列化更新，使他们连续的工作。

### 1.1 version 1.0项目功能
简单存储和读写

### 1.2 version 2.0项目功能
增加持久化存储

### 1.3 version 3.0项目功能
如果太多客户端试图同时添加URLs，那么会出现问题。
这是因为我们的map是一个全局变量，因此它是一个共享资源。如果多个客户端同时尝试添加URLs，那么它们可能会同时读取和写入map，这可能会导致数据丢失或者数据不一致。
为了解决这个问题，version2.0使用了互斥锁来保护map，以确保在同一时间只有一个客户端能够访问它。

但是由于锁定机制，每一条记录是立即写入磁盘的，这样会导致性能下降。磁盘写入可能会同时发生，并且根据你的操作系统的特性，可能会导致崩溃。
即使写入不会冲突，每个客户端在 Put 函数返回之前，必须等待他们的数据写入到磁盘。因此，在 I/O 负载大的系统上，客户端需要等待的时间将超过完成添加请求所必须的时间。

为了解决这个问题，version3.0使用了一个goroutine来处理写入请求，这样就可以在不影响性能的情况下，保证数据的一致性。
具体而言，是将 Put 与 Save 的过程解耦合：通过 Go 的并发机制做到这点。不再将记录直接保存到磁盘，而是发送它们到一个通道，这是一种缓冲，所以发送函数不需要再等待它。
然后，我们启动一个 goroutine 来处理这些记录，这样就可以在不影响性能的情况下，保证数据的一致性。
写入磁盘的保存过程从这个通道读取，并且是启动在一个叫 saveloop 的协程单独启动的线程上。主程序与 saveloop 是同时执行的，所以没有那么多的阻塞。

### 1.4 version 4.0项目功能
使用json存储

## 2. 项目结构
```
├── README.md
├── src 
│   ├── store.go // 定义了数据存储和处理它的函数
│   ├── main.go // 主函数
│   ├── key.go // 定义了key的生成函数
├── file 
    ├── store.gob // 存储数据的文件
```
![](https://image-20220620.oss-cn-guangzhou.aliyuncs.com/image/20230419171551.png)
